# æœç´¢

## Backtracking å›æº¯ç®—æ³•

Backtracking is a systematic way to iterate through all possible configurations of a seach space.


å…¶å®å›æº¯ç®—æ³•å’Œæˆ‘ä»¬å¸¸è¯´çš„ DFS ç®—æ³•éå¸¸ç±»ä¼¼ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ç§æš´åŠ›ç©·ä¸¾ç®—æ³•ã€‚å›æº¯ç®—æ³•å’Œ DFS ç®—æ³•çš„ç»†å¾®å·®åˆ«æ˜¯ï¼šå›æº¯ç®—æ³•æ˜¯åœ¨éå†ã€Œæ ‘æã€ï¼ŒDFS ç®—æ³•æ˜¯åœ¨éå†ã€ŒèŠ‚ç‚¹ã€ï¼Œæœ¬æ–‡å°±æ˜¯ç®€å•æä¸€ä¸‹ï¼Œä½ æœ‰ä¸ªå°è±¡å°±è¡Œäº†ã€‚ç­‰ä½ çœ‹äº† æ‰‹æŠŠæ‰‹åˆ·äºŒå‰æ ‘ï¼ˆçº²é¢†ç¯‡ï¼‰ å’Œ å›¾è®ºç®—æ³•åŸºç¡€ ä¹‹åå°±èƒ½æ·±åˆ»ç†è§£è¿™å¥è¯çš„å«ä¹‰äº†ã€‚

æŠ½è±¡åœ°è¯´ï¼Œè§£å†³ä¸€ä¸ªå›æº¯é—®é¢˜ï¼Œå®é™…ä¸Šå°±æ˜¯éå†ä¸€æ£µå†³ç­–æ ‘çš„è¿‡ç¨‹ï¼Œæ ‘çš„æ¯ä¸ªå¶å­èŠ‚ç‚¹å­˜æ”¾ç€ä¸€ä¸ªåˆæ³•ç­”æ¡ˆã€‚ä½ æŠŠæ•´æ£µæ ‘éå†ä¸€éï¼ŒæŠŠå¶å­èŠ‚ç‚¹ä¸Šçš„ç­”æ¡ˆéƒ½æ”¶é›†èµ·æ¥ï¼Œå°±èƒ½å¾—åˆ°æ‰€æœ‰çš„åˆæ³•ç­”æ¡ˆã€‚

ç«™åœ¨å›æº¯æ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹ä¸Šï¼Œä½ åªéœ€è¦æ€è€ƒ 3 ä¸ªé—®é¢˜ï¼š

1. è·¯å¾„ï¼šä¹Ÿå°±æ˜¯å·²ç»åšå‡ºçš„é€‰æ‹©ã€‚
2. é€‰æ‹©åˆ—è¡¨ï¼šä¹Ÿå°±æ˜¯ä½ å½“å‰å¯ä»¥åšçš„é€‰æ‹©ã€‚
3. ç»“æŸæ¡ä»¶ï¼šä¹Ÿå°±æ˜¯åˆ°è¾¾å†³ç­–æ ‘åº•å±‚ï¼Œæ— æ³•å†åšé€‰æ‹©çš„æ¡ä»¶ã€‚

### å›æº¯ç®—æ³•å’ŒDFSçš„åŒºåˆ«

å›æº¯ç®—æ³•å…³æ³¨çš„ä¸æ˜¯èŠ‚ç‚¹ï¼Œè€Œæ˜¯æ ‘æã€‚

```java
// DFS ç®—æ³•ï¼Œå…³æ³¨ç‚¹åœ¨èŠ‚ç‚¹
void traverse(TreeNode root) {
    if (root == null) return;
    printf("è¿›å…¥èŠ‚ç‚¹ %s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    printf("ç¦»å¼€èŠ‚ç‚¹ %s", root);
}

// å›æº¯ç®—æ³•ï¼Œå…³æ³¨ç‚¹åœ¨æ ‘æ
void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // åšé€‰æ‹©
        printf("ä» %s åˆ° %s", root, child);
        backtrack(child);
        // æ’¤é”€é€‰æ‹©
        printf("ä» %s åˆ° %s", child, root);
    }
}
```

[å›æº¯ç®—æ³•ç§’æ€æ‰€æœ‰æ’åˆ—/ç»„åˆ/å­é›†é—®é¢˜](https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/hui-su-sua-56e11/)

```
æ— è®ºæ˜¯æ’åˆ—ã€ç»„åˆè¿˜æ˜¯å­é›†é—®é¢˜ï¼Œç®€å•è¯´æ— éå°±æ˜¯è®©ä½ ä»åºåˆ— nums ä¸­ä»¥ç»™å®šè§„åˆ™å–è‹¥å¹²å…ƒç´ ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç§å˜ä½“ï¼š

- å½¢å¼ä¸€ã€å…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™ä¹Ÿæ˜¯æœ€åŸºæœ¬çš„å½¢å¼ã€‚

ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥åªæœ‰ [7]ã€‚

- å½¢å¼äºŒã€å…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ å¯ä»¥å­˜åœ¨é‡å¤ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚

ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,5,2,1,2]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,2,1] å’Œ [5,2]ã€‚

- å½¢å¼ä¸‰ã€å…ƒç´ æ— é‡å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥è¢«ä½¿ç”¨è‹¥å¹²æ¬¡ã€‚

ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,3] å’Œ [7]ã€‚

å½“ç„¶ï¼Œä¹Ÿå¯ä»¥è¯´æœ‰ç¬¬å››ç§å½¢å¼ï¼Œå³å…ƒç´ å¯é‡å¯å¤é€‰ã€‚ä½†æ—¢ç„¶å…ƒç´ å¯å¤é€‰ï¼Œé‚£åˆä½•å¿…å­˜åœ¨é‡å¤å…ƒç´ å‘¢ï¼Ÿå…ƒç´ å»é‡ä¹‹åå°±ç­‰åŒäºå½¢å¼ä¸‰ï¼Œæ‰€ä»¥è¿™ç§æƒ…å†µä¸ç”¨è€ƒè™‘ã€‚

ä¸Šé¢ç”¨ç»„åˆé—®é¢˜ä¸¾çš„ä¾‹å­ï¼Œä½†æ’åˆ—ã€ç»„åˆã€å­é›†é—®é¢˜éƒ½å¯ä»¥æœ‰è¿™ä¸‰ç§åŸºæœ¬å½¢å¼ï¼Œæ‰€ä»¥å…±æœ‰ 9 ç§å˜åŒ–ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œé¢˜ç›®ä¹Ÿå¯ä»¥å†æ·»åŠ å„ç§é™åˆ¶æ¡ä»¶ï¼Œæ¯”å¦‚è®©ä½ æ±‚å’Œä¸º target ä¸”å…ƒç´ ä¸ªæ•°ä¸º k çš„ç»„åˆï¼Œé‚£è¿™ä¹ˆä¸€æ¥åˆå¯ä»¥è¡ç”Ÿå‡ºä¸€å †å˜ä½“ï¼Œæ€ªä¸å¾—é¢è¯•ç¬”è¯•ä¸­ç»å¸¸è€ƒåˆ°æ’åˆ—ç»„åˆè¿™ç§åŸºæœ¬é¢˜å‹ã€‚

ä½†æ— è®ºå½¢å¼æ€ä¹ˆå˜åŒ–ï¼Œå…¶æœ¬è´¨å°±æ˜¯ç©·ä¸¾æ‰€æœ‰è§£ï¼Œè€Œè¿™äº›è§£å‘ˆç°æ ‘å½¢ç»“æ„ï¼Œæ‰€ä»¥åˆç†ä½¿ç”¨å›æº¯ç®—æ³•æ¡†æ¶ï¼Œç¨æ”¹ä»£ç æ¡†æ¶å³å¯æŠŠè¿™äº›é—®é¢˜ä¸€ç½‘æ‰“å°½ã€‚
```

é¦–å…ˆï¼Œç»„åˆé—®é¢˜å’Œå­é›†é—®é¢˜å…¶å®æ˜¯ç­‰ä»·çš„ï¼Œè¿™ä¸ªåé¢ä¼šè®²ï¼›è‡³äºä¹‹å‰è¯´çš„ä¸‰ç§å˜åŒ–å½¢å¼ï¼Œæ— éæ˜¯åœ¨è¿™ä¸¤æ£µæ ‘ä¸Šå‰ªæ‰æˆ–è€…å¢åŠ ä¸€äº›æ ‘æç½¢äº†ã€‚

#### å…¸å‹é—®é¢˜

##### å­é›† Subsets ï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰

**Leetcode 78**

    è¾“å…¥ä¸€ä¸ªæ— é‡å¤å…ƒç´ çš„æ•°ç»„ numsï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ æœ€å¤šä½¿ç”¨ä¸€æ¬¡ï¼Œè¯·ä½ è¿”å› nums çš„æ‰€æœ‰å­é›†ã€‚


```python
from typing import List

class Solution: 
    def __init__(self):
        self.res = []
        # è®°å½•å›æº¯ç®—æ³•çš„é€’å½’è·¯å¾„
        self.track = []

    # ä¸»å‡½æ•°
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.backtrack(nums, 0)
        return self.res
    
    # å›æº¯ç®—æ³•æ ¸å¿ƒå‡½æ•°ï¼Œéå†å­é›†é—®é¢˜çš„å›æº¯æ ‘
    def backtrack(self, nums: List[int], start: int) -> None:     
        # å‰åºä½ç½®ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯ä¸€ä¸ªå­é›†
        self.res.append(list(self.track))
        
        # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for i in range(start, len(nums)):
            # åšé€‰æ‹©
            self.track.append(nums[i])
            # é€šè¿‡ start å‚æ•°æ§åˆ¶æ ‘æçš„éå†ï¼Œé¿å…äº§ç”Ÿé‡å¤çš„å­é›†
            self.backtrack(nums, i + 1)
            # æ’¤é”€é€‰æ‹©
            self.track.pop()
```

##### ç»„åˆ Combinations ï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰

**Leetcode 77**

    ç»™å®šä¸¤ä¸ªæ•´æ•° n å’Œ kï¼Œè¿”å›èŒƒå›´ [1, n] ä¸­æ‰€æœ‰å¯èƒ½çš„ k ä¸ªæ•°çš„ç»„åˆã€‚è¿™æ˜¯æ ‡å‡†çš„ç»„åˆé—®é¢˜ï¼Œä½†æˆ‘ç»™ä½ ç¿»è¯‘ä¸€ä¸‹å°±å˜æˆå­é›†é—®é¢˜äº†ï¼šç»™ä½ è¾“å…¥ä¸€ä¸ªæ•°ç»„ nums = [1,2..,n] å’Œä¸€ä¸ªæ­£æ•´æ•° kï¼Œè¯·ä½ ç”Ÿæˆæ‰€æœ‰å¤§å°ä¸º k çš„å­é›†ã€‚

```python
from typing import List

class Solution:
    def __init__(self):
        self.res = []
        # è®°å½•å›æº¯ç®—æ³•çš„é€’å½’è·¯å¾„
        self.track = []

    # ä¸»å‡½æ•°
    def combine(self, n: int, k: int) -> List[List[int]]:
        self.backtrack(1, n, k)
        return self.res

    def backtrack(self, start: int, n: int, k: int) -> None:
        # base case
        if k == len(self.track):
            # éå†åˆ°äº†ç¬¬ k å±‚ï¼Œæ”¶é›†å½“å‰èŠ‚ç‚¹çš„å€¼
            self.res.append(self.track.copy())
            return
        
        # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for i in range(start, n+1):
            # é€‰æ‹©
            self.track.append(i)
            # é€šè¿‡ start å‚æ•°æ§åˆ¶æ ‘æçš„éå†ï¼Œé¿å…äº§ç”Ÿé‡å¤çš„å­é›†
            self.backtrack(i + 1, n, k)
            # æ’¤é”€é€‰æ‹©
            self.track.pop()
```

##### æ’åˆ— Permutations ï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰

**Leetcode 46**

    ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ numsï¼Œè¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—ã€‚

åˆšæ‰è®²çš„ç»„åˆ/å­é›†é—®é¢˜ä½¿ç”¨ start å˜é‡ä¿è¯å…ƒç´  nums[start] ä¹‹ååªä¼šå‡ºç° nums[start+1..] ä¸­çš„å…ƒç´ ï¼Œé€šè¿‡å›ºå®šå…ƒç´ çš„ç›¸å¯¹ä½ç½®ä¿è¯ä¸å‡ºç°é‡å¤çš„å­é›†ã€‚

ä½†æ’åˆ—é—®é¢˜æœ¬èº«å°±æ˜¯è®©ä½ ç©·ä¸¾å…ƒç´ çš„ä½ç½®ï¼Œnums[i] ä¹‹åä¹Ÿå¯ä»¥å‡ºç° nums[i] å·¦è¾¹çš„å…ƒç´ ï¼Œæ‰€ä»¥ä¹‹å‰çš„é‚£ä¸€å¥—ç©ä¸è½¬äº†ï¼Œéœ€è¦é¢å¤–ä½¿ç”¨ used æ•°ç»„æ¥æ ‡è®°å“ªäº›å…ƒç´ è¿˜å¯ä»¥è¢«é€‰æ‹©ã€‚

æˆ‘ä»¬ç”¨`used`æ•°ç»„æ ‡è®°å·²ç»åœ¨è·¯å¾„ä¸Šçš„å…ƒç´ é¿å…é‡å¤é€‰æ‹©ï¼Œç„¶åæ”¶é›†æ‰€æœ‰å¶å­èŠ‚ç‚¹ä¸Šçš„å€¼ï¼Œå°±æ˜¯æ‰€æœ‰å…¨æ’åˆ—çš„ç»“æœï¼š

```python
from typing import List

class Solution:
    res = []
    #è®°å½•å›æº¯ç®—æ³•çš„é€’å½’è·¯å¾„
    track = []
    # track ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º true
    used = []

    # ä¸»å‡½æ•°ï¼Œè¾“å…¥ä¸€ç»„ä¸é‡å¤çš„æ•°å­—ï¼Œè¿”å›å®ƒä»¬çš„å…¨æ’åˆ—
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.used = [False] * len(nums)
        self.backtrack(nums)
        return self.res

    # å›æº¯ç®—æ³•æ ¸å¿ƒå‡½æ•°
    def backtrack(self, nums):
        # base caseï¼Œåˆ°è¾¾å¶å­èŠ‚ç‚¹
        if len(self.track) == len(nums):
            # æ”¶é›†å¶å­èŠ‚ç‚¹ä¸Šçš„å€¼
            self.res.append(self.track[:])
            return

        # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for i in range(len(nums)):
            # å·²ç»å­˜åœ¨ track ä¸­çš„å…ƒç´ ï¼Œä¸èƒ½é‡å¤é€‰æ‹©
            if self.used[i]:
                continue
            # åšé€‰æ‹©
            self.used[i] = True
            self.track.append(nums[i])
            # è¿›å…¥ä¸‹ä¸€å±‚å›æº¯æ ‘
            self.backtrack(nums)
            # å–æ¶ˆé€‰æ‹©
            self.track.remove(nums[i])
            self.used[i] = False
```

ä½†å¦‚æœé¢˜ç›®ä¸è®©ä½ ç®—å…¨æ’åˆ—ï¼Œè€Œæ˜¯è®©ä½ ç®—å…ƒç´ ä¸ªæ•°ä¸º k çš„æ’åˆ—ï¼Œæ€ä¹ˆç®—ï¼Ÿ

ä¹Ÿå¾ˆç®€å•ï¼Œæ”¹ä¸‹ backtrack å‡½æ•°çš„ base caseï¼Œä»…æ”¶é›†ç¬¬ k å±‚çš„èŠ‚ç‚¹å€¼å³å¯ï¼š

```python
# å›æº¯ç®—æ³•æ ¸å¿ƒå‡½æ•°
def backtrack(nums: List[int], k: int) -> None:
    # base caseï¼Œåˆ°è¾¾ç¬¬ k å±‚ï¼Œæ”¶é›†èŠ‚ç‚¹çš„å€¼
    if len(track) == k:
        # ç¬¬ k å±‚èŠ‚ç‚¹çš„å€¼å°±æ˜¯å¤§å°ä¸º k çš„æ’åˆ—
        res.append(track[:])
        return

    # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
    for i in range(len(nums)):
        # ...
        backtrack(nums, k)
        # ...
```

##### å­é›†/ç»„åˆ Subsetsï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰

åˆšæ‰è®²çš„æ ‡å‡†å­é›†é—®é¢˜è¾“å…¥çš„ nums æ˜¯æ²¡æœ‰é‡å¤å…ƒç´ çš„ï¼Œä½†å¦‚æœå­˜åœ¨é‡å¤å…ƒç´ ï¼Œæ€ä¹ˆå¤„ç†å‘¢ï¼Ÿ

**Leetcode 90**

    ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ã€‚

éœ€è¦å…ˆè¿›è¡Œæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·ï¼Œå¦‚æœå‘ç° nums[i] == nums[i-1]ï¼Œåˆ™è·³è¿‡ï¼š


```cpp
// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç ä¸ä¿è¯æ­£ç¡®æ€§ï¼Œä»…ä¾›å‚è€ƒã€‚å¦‚æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å‚ç…§æˆ‘å†™çš„ java ä»£ç å¯¹æ¯”æŸ¥çœ‹ã€‚

class Solution {
    vector<vector<int>> res; // è¾“å‡ºç»“æœ
    vector<int> track; // æœç´¢è·¯å¾„
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end()); // æ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        backtrack(nums, 0);
        return res; // è¿”å›ç»“æœ
    }

    void backtrack(vector<int>& nums, int start) { // start ä¸ºå½“å‰çš„æšä¸¾ä½ç½®
        res.emplace_back(track); // å‰åºä½ç½®ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯ä¸€ä¸ªå­é›†
        for(int i = start; i < nums.size(); i++) {
            if (i > start && nums[i] == nums[i - 1]) { // å‰ªæé€»è¾‘ï¼Œå€¼ç›¸åŒçš„ç›¸é‚»æ ‘æï¼Œåªéå†ç¬¬ä¸€æ¡
                continue;
            }
            track.emplace_back(nums[i]); // æ·»åŠ è‡³è·¯å¾„
            backtrack(nums, i + 1); // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            track.pop_back(); // å›æº¯
        }
    }
};
```

è¿™æ®µä»£ç å’Œä¹‹å‰æ ‡å‡†çš„å­é›†é—®é¢˜çš„ä»£ç å‡ ä¹ç›¸åŒï¼Œå°±æ˜¯æ·»åŠ äº†æ’åºå’Œå‰ªæçš„é€»è¾‘ã€‚

è‡³äºä¸ºä»€ä¹ˆè¦è¿™æ ·å‰ªæï¼Œç»“åˆå‰é¢çš„å›¾åº”è¯¥ä¹Ÿå¾ˆå®¹æ˜“ç†è§£ï¼Œè¿™æ ·å¸¦é‡å¤å…ƒç´ çš„å­é›†é—®é¢˜ä¹Ÿè§£å†³äº†ã€‚

æˆ‘ä»¬è¯´äº†ç»„åˆé—®é¢˜å’Œå­é›†é—®é¢˜æ˜¯ç­‰ä»·çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥çœ‹ä¸€é“ç»„åˆçš„é¢˜ç›®å§ã€‚

**Leetcode 40**

    ç»™ä½ è¾“å…¥ candidates å’Œä¸€ä¸ªç›®æ ‡å’Œ targetï¼Œä» candidates ä¸­æ‰¾å‡ºä¸­æ‰€æœ‰å’Œä¸º target çš„ç»„åˆã€‚candidates å¯èƒ½å­˜åœ¨é‡å¤å…ƒç´ ï¼Œä¸”å…¶ä¸­çš„æ¯ä¸ªæ•°å­—æœ€å¤šåªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚

è¯´è¿™æ˜¯ä¸€ä¸ªç»„åˆé—®é¢˜ï¼Œå…¶å®æ¢ä¸ªé—®æ³•å°±å˜æˆå­é›†é—®é¢˜äº†ï¼šè¯·ä½ è®¡ç®— candidates ä¸­æ‰€æœ‰å’Œä¸º target çš„å­é›†ã€‚æ‰€ä»¥è¿™é¢˜æ€ä¹ˆåšå‘¢ï¼Ÿ

å¯¹æ¯”å­é›†é—®é¢˜çš„è§£æ³•ï¼Œåªè¦é¢å¤–ç”¨ä¸€ä¸ª trackSum å˜é‡è®°å½•å›æº¯è·¯å¾„ä¸Šçš„å…ƒç´ å’Œï¼Œç„¶åå°† base case æ”¹ä¸€æ”¹å³å¯è§£å†³è¿™é“é¢˜ï¼š

```cpp
// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç ä¸ä¿è¯æ­£ç¡®æ€§ï¼Œä»…ä¾›å‚è€ƒã€‚å¦‚æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å‚ç…§æˆ‘å†™çš„ java ä»£ç å¯¹æ¯”æŸ¥çœ‹ã€‚

class Solution {
public:
    vector<vector<int>> res;
    //è®°å½•å›æº¯çš„è·¯å¾„
    vector<int> track;
    //è®°å½• track ä¸­çš„å…ƒç´ ä¹‹å’Œ
    int trackSum = 0;

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, 0, target);
        return res;
    }

    //å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(vector<int>& nums, int start, int target) {
        //base caseï¼Œè¾¾åˆ°ç›®æ ‡å’Œï¼Œæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ç»„åˆ
        if(trackSum == target) {
            res.push_back(track);
            return;
        }
        //base caseï¼Œè¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
        if(trackSum > target) {
            return;
        }

        //å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for(int i = start; i < nums.size(); i++) {
            //å‰ªæé€»è¾‘ï¼Œå€¼ç›¸åŒçš„æ ‘æï¼Œåªéå†ç¬¬ä¸€æ¡
            if(i > start && nums[i] == nums[i-1]) {
                continue;
            }
            //åšé€‰æ‹©
            track.push_back(nums[i]);
            trackSum += nums[i];
            //é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(nums, i+1, target);
            //æ’¤é”€é€‰æ‹©
            track.pop_back();
            trackSum -= nums[i];
        }
    }
};
```

##### æ’åˆ—ï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰

æ’åˆ—é—®é¢˜çš„è¾“å…¥å¦‚æœå­˜åœ¨é‡å¤ï¼Œæ¯”å­é›†/ç»„åˆé—®é¢˜ç¨å¾®å¤æ‚ä¸€ç‚¹ã€‚

**Leetcode 47**

    ç»™ä½ è¾“å…¥ä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— numsï¼Œè¯·ä½ å†™ä¸€ä¸ªç®—æ³•ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—ï¼Œå‡½æ•°ç­¾åå¦‚ä¸‹ï¼š

```cpp
// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç ä¸ä¿è¯æ­£ç¡®æ€§ï¼Œä»…ä¾›å‚è€ƒã€‚å¦‚æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å‚ç…§æˆ‘å†™çš„ java ä»£ç å¯¹æ¯”æŸ¥çœ‹ã€‚

class Solution {
public:
    // ä¿å­˜ç»“æœ
    vector<vector<int>> res;
    // è®°å½•å½“å‰ä½ç½®çš„å…ƒç´ 
    vector<int> track;
    // è®°å½•å…ƒç´ æ˜¯å¦è¢«ä½¿ç”¨
    vector<bool> used;

    // ä¸»å‡½æ•°
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        // æ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        sort(nums.begin(), nums.end());
        // åˆå§‹åŒ–usedæ•°ç»„
        used = vector<bool>(nums.size(), false);
        // å›æº¯
        backtrack(nums);
        // è¿”å›ç»“æœ
        return res;
    }

    // å›æº¯å‡½æ•°
    void backtrack(vector<int>& nums) {
        // å½“é•¿åº¦ç›¸ç­‰æ—¶ï¼Œå°†ç»“æœè®°å½•
        if (track.size() == nums.size()) {
            res.push_back(track);
            return;
        }

        // éå†æ²¡æœ‰è¢«ä½¿ç”¨è¿‡çš„å…ƒç´ 
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) {
                continue;
            }
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            // æ·»åŠ å…ƒç´ ï¼Œæ ‡è®°ä¸ºä½¿ç”¨è¿‡
            track.push_back(nums[i]);
            used[i] = true;
            // ç»§ç»­å›æº¯
            backtrack(nums);
            // å›æº¯
            track.pop_back();
            used[i] = false;
        }
    }
};
```

ä½ å¯¹æ¯”ä¸€ä¸‹ä¹‹å‰çš„æ ‡å‡†å…¨æ’åˆ—è§£æ³•ä»£ç ï¼Œè¿™æ®µè§£æ³•ä»£ç åªæœ‰ä¸¤å¤„ä¸åŒï¼š

1. å¯¹ nums è¿›è¡Œäº†æ’åºã€‚

2. æ·»åŠ äº†ä¸€å¥é¢å¤–çš„å‰ªæé€»è¾‘ã€‚

ç±»æ¯”è¾“å…¥åŒ…å«é‡å¤å…ƒç´ çš„å­é›†/ç»„åˆé—®é¢˜ï¼Œä½ å¤§æ¦‚åº”è¯¥ç†è§£è¿™ä¹ˆåšæ˜¯ä¸ºäº†é˜²æ­¢å‡ºç°é‡å¤ç»“æœã€‚

ä½†æ˜¯æ³¨æ„æ’åˆ—é—®é¢˜çš„å‰ªæé€»è¾‘ï¼Œå’Œå­é›†/ç»„åˆé—®é¢˜çš„å‰ªæé€»è¾‘ç•¥æœ‰ä¸åŒï¼šæ–°å¢äº† !used[i - 1] çš„é€»è¾‘åˆ¤æ–­ã€‚



# å›¾ç®—æ³•


æœ‰ä¸¤ç§å›¾éå†ç®—æ³•ï¼šBFSå’ŒDFSã€‚åŒºåˆ«åœ¨äºæ¢ç´¢èŠ‚ç‚¹çš„é¡ºåºã€‚Queue-BFSï¼ŒStack-DFSã€‚

[å›¾è®ºåŸºç¡€åŠéå†ç®—æ³•](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/)

## Depth-First Search æ·±åº¦ä¼˜å…ˆæœç´¢  

DFSçš„åº”ç”¨ [The Algorithm Design Manual](The Algorithm Design Manual)

### Finding Circles 

Back edges are the key to finding a cycle in an undirected graph. If there is no back edge, all edges are tree edges, and no cycle exists in a tree.

```
process_edge(int x, int y) {
    if (parent[x] != y) { /* found back edge! */
        printf("Cycle from %d to %d", y, x);
        find_path(y, x, parent);
        finished = TRUE;
    }
}
```

### Articulation Vertices

A single vertex whose deletion disconnects a connected component of the graph. Such a vertex is called an *articulation vertex* or *cut-node*.

## Breadth-First Search å¹¿åº¦ä¼˜å…ˆæœç´¢

# å‚è€ƒ

1. The Algorithm Design Manual

